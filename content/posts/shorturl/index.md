---
title: Hashids
date: 2021-10-07
tags:
- Hashids
---

最近被一个短链服务坑了, 生成短码的时候使用了hash, 但是没有考虑冲突的情况, 导致固定链接短链生成失败. 没办法, 只能去改源链接碰碰运气避免冲突了

通过这个问题我们顺便来看一下Hashids是如何生成短码的.

# 常见的短码生成策略

### 哈希算法

1. 将长网址md5生成32位签名串,分为4段, 每段8个字节；
2. 对这四段循环处理, 取8个字节, 将他看成16进制串与0x3fffffff(30位1)与操作, 即超过30位的忽略处理；
3. 这30位分成6段, 每5位的数字作为字母表的索引取得特定字符, 依次进行获得6位字符串；
4. 总的md5串可以获得4个6位串；取里面的任意一个就可作为这个长url的短url地址；

这种算法,虽然会生成4个,但是仍然存在重复几率，解决冲突可以通过补位等办法解决，但是会比较麻烦，也可能会再次冲突导致效率低。不过该方法生成的短码位数是固定的，也不存在连续生成的短码有序的情况。

### 自增id

该方法是一种无碰撞的方法，原理是每新增一个短码，就在上次添加的短码id基础上加1，然后将这个10进制的id值转化62进制。

一般利用数据表或者redis中的自增值来完成。

但是短码 id 是从一位长度开始递增，短码的长度不固定，而且生成的短码是有序的，很容易被遍历

# 自增id+Hashids

考虑到前面两种方式的优缺点, 我们决定使用第二种并结合`Hashids`来生成固定位数的短码, 既能保证性能又防止产生规律导致可遍历

实现步骤:

1. 由redis来提供自增的id生成
2. 使用`Hashids`对生成的id进行编码
   1. 初始化
      - 指定**盐值**用来扰乱62进制字符数组 测试盐值:tgest
      - 指定**短码最小位数**为6
      - 62进制字符表排除掉`cfhistuCFHISTU`14个字符后使用盐值打乱顺序得到48位乱序字符表`Elgm69eXxopQ3Vwn4A5082yNYRjPaZ1WOJGBDdkqvrMLKzb7`, 防止产生英文敏感词
      - `cfhistuCFHISTU`使用盐值打乱顺序得到`IcfHFshuCTitUS`
      - 在乱序字符表剩余的48个字符中截取前四个字符用来作为**补位字符分隔符**, 值为`Elgm` 
      - 生成最终44个字符的**乱序字符表**为`69eXxopQ3Vwn4A5082yNYRjPaZ1WOJGBDdkqvrMLKzb7`
   2. encode
      - 取数字1在初始化乱序字符表中取余后对应位置上的字符作为**数字位标识符**(目前我们只会decode一个数字), 得到9
      - <u>数字位标识符+ 盐值 + 字符表</u> 作为新的盐值重新打乱字符表得到新的乱序字符表`x5kw2P6GazKypZRbJB730DLVdYojev8nAXqrWNQ194MO`
      - <u>**数字位标识符**+将数字1使用最新打乱的字符表转为**44进制短码**</u>得到`95`
      - 没有达到6位, 在**补位字符分隔符**`Elgm` 选取两位分别补到95的前后得到`g95g`
      - 没有达到6位, 循环使用乱序字符表作为盐值再次打乱得到新的字符表`zQa4PAqDGyx1VWn9kvjN2ZoOb3XL8edwMK7JpR6r50BY`, 从中选取字符分别在`g95g`前后进行补位知道满足长度, 得到`Yg95gz`返回

最终生成的短码中只有分隔符中间的字符与真实的数字有关系, 因为分隔符在使用盐值打乱后的数组中选取的, 同时生成短码的过程中字符表也经历了两轮打乱, 所以在不知道盐值的情况下很难找到规律遍历

> Hashids虽然叫hash, 但其实跟hash算法一点关系也没有, 所以是可逆的并且效率很高